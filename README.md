# goit-algo-hw-04

Ми проганяємо дані на двох типах масивів: коротких і довгих
Це потрібно для того щоб наглядно побачити ефективність кожного алгоритму сортування

Наприклад:
СОРТУВАННЯ ВСТАВКАМИ
Дуже ефективне на малих масивах, порівняно з алгоритмом злиття швидший від нього вдвічі
але на великих масивах ситуація вже зовсім інша, сортування вставками повільніше мінімум в 10 раз
від сортування злиттям

СОРТУВАННЯ ЗЛИТТЯМ
Згідно наших замірів ми можемо побачити що час сортування злиттям приблизно сталий в залежності від масива
тобто його складність не змінюється зі зміною обсягу даних, тим самим він залишається ефективним однаково на будь якому рівні

СОРТУВАННЯ TIMSORT
Тут ситуація у нас зовсім інша, даний принцим ефективний на будь-яких розмірах масивів і швидче за попередників
зі збільшенням масиву та кількості прогонів в 100 раз, швидкість сортування змінилась всього на приблизно 0.003 секунди
З чим це пов'язано? 
Алгоритм сортування злиттям розділяє великий масив на малі підмасиви, а вже алгоритм сортування вставками працює з цим малим масивом
тобто коли розділення підходить до певного рівня, починає працювати над ефективний на цьому рівні алгоритм сортування вставками
тим самим забезпечуючи високу швидкість, а при поверненні сортованих масивів проходиться галопом по них і вставляє 
дані вже у відсортовані місця застосовуючи бінарний пошук який у нас є O(log n)


ВИСНОВКИ
З зроблених тестів та наданих вищенаведених пояснень робимо висновок що вбудовані функці python найбільш ефективні в цій мові
програмування, тому більшість програмістів використовують вбудовані функції python. Також варто зазначити що під капотом
одна з найшвидчих мов програмування C++, тому немає сенсу використовувати власні алгоритми для більшості задач, хоча є і такі
які потребують власних рішень.
